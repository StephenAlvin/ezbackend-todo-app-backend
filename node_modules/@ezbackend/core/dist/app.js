"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = exports.AppInstanceOpts = exports.AppInstance = exports.LIFECYCLE = exports.PluginScope = void 0;
var symbols_1 = require("./symbols");
var avvio_1 = __importDefault(require("avvio"));
var PluginScope;
(function (PluginScope) {
    PluginScope[PluginScope["PARENT"] = 0] = "PARENT";
    PluginScope[PluginScope["DEFAULT"] = 1] = "DEFAULT";
})(PluginScope = exports.PluginScope || (exports.PluginScope = {}));
exports.LIFECYCLE = [
    '_preInit',
    '_init',
    '_postInit',
    '_preHandler',
    '_handler',
    '_postHandler',
    '_preRun',
    '_run',
    '_postRun'
];
var AppInstance = /** @class */ (function () {
    function AppInstance() {
    }
    return AppInstance;
}());
exports.AppInstance = AppInstance;
var AppInstanceOpts = /** @class */ (function () {
    function AppInstanceOpts() {
    }
    return AppInstanceOpts;
}());
exports.AppInstanceOpts = AppInstanceOpts;
//TODO: Added safety for overriding instance variables?
/**
 * An App is the basic building block for a plugin system, it contains all core and lifecycle methods.
 *
 * **App Lifecycle**
 *
 * {@link setPreInit} → {@link setInit} → {@link setPostInit}
 *
 * → {@link setPreHandler} → {@link setHandler} → {@link setPostHandler}
 *
 * → {@link setPreRun} → {@link setRun} → {@link setPostRun}
 *
 */
var App = /** @class */ (function () {
    //TODO: Add tests for localdata
    //TOOD: Add test for obtaining parent
    //TODO: Replace errors with better errors
    function App() {
        var _this = this;
        /**
         *
         * @param old
         * @param fn
         * @param opts
         * @returns
         */
        this.override = function (old, fn, opts) {
            var _a;
            var newInstance;
            var parentApp = (_a = fn.prototype[symbols_1.kApp]) !== null && _a !== void 0 ? _a : _this;
            //Check plugin scope
            if (fn.prototype[symbols_1.kScope] === PluginScope.DEFAULT) {
                //Uses new scope
                if (parentApp[symbols_1.kInstance] === undefined) {
                    parentApp[symbols_1.kInstance] = Object.create(old);
                    Object.entries(_this.overrides).forEach(function (_a) {
                        var varName = _a[0], override = _a[1];
                        if (parentApp[symbols_1.kInstance][varName] === undefined) {
                            //Don't do anything if variable has not been defined yet
                            return;
                        }
                        parentApp[symbols_1.kInstance][varName] = override(parentApp[symbols_1.kInstance][varName], function (instance, opts) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            return [2 /*return*/];
                        }); }); }, parentApp.opts);
                    });
                }
                newInstance = parentApp[symbols_1.kInstance];
            }
            else if (fn.prototype[symbols_1.kScope] === PluginScope.PARENT) {
                //Uses old scope
                newInstance = old;
            }
            else {
                throw new Error("Function scope is ".concat(fn.prototype[symbols_1.kScope], " for ").concat(fn, ", but needs to be ").concat(PluginScope));
            }
            newInstance[symbols_1.kApp] = parentApp;
            return newInstance;
        };
        this._apps = new Map();
        this._preInit = new Map();
        this._init = new Map();
        this._postInit = new Map();
        this._preHandler = new Map();
        this._handler = new Map();
        this._postHandler = new Map();
        this._preRun = new Map();
        this._run = new Map();
        this._postRun = new Map();
        this._instance = (0, avvio_1.default)(new AppInstance(), { autostart: false });
        this._name = 'Root';
        this._scope = PluginScope.DEFAULT;
        this._overrides = {};
        this.opts = {};
        this._unnamedCounter = 1;
    }
    Object.defineProperty(App.prototype, "apps", {
        get: function () { return this._apps; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "init", {
        get: function () { return this._init; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "handler", {
        get: function () { return this._handler; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "run", {
        get: function () { return this._run; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "instance", {
        get: function () { return this._instance; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "name", {
        get: function () { return this._name; },
        set: function (newName) {
            //Should we prevent setting the name more than once?
            this._name = newName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "scope", {
        get: function () { return this._scope; },
        set: function (newScope) {
            this._scope = newScope;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(App.prototype, "overrides", {
        get: function () { return this._overrides; },
        enumerable: false,
        configurable: true
    });
    /**
     * Set's it's argument function as a hook during the {@link setPreInit} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPreInit = function (funcName, plugin) {
        this.setHook('_preInit', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setInit} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setInit = function (funcName, plugin) {
        this.setHook('_init', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setPostInit} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPostInit = function (funcName, plugin) {
        this.setHook('_postInit', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setPreHandler} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPreHandler = function (funcName, plugin) {
        this.setHook('_preHandler', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setHandler} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setHandler = function (funcName, plugin) {
        this.setHook('_handler', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setPostHandler} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPostHandler = function (funcName, plugin) {
        this.setHook('_postHandler', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setPreRun} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPreRun = function (funcName, plugin) {
        this.setHook('_preRun', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setRun} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setRun = function (funcName, plugin) {
        this.setHook('_run', funcName, plugin);
    };
    /**
     * Set's it's argument function as a hook during the {@link setPostRun} point of the lifecycle
     * @param funcName Name of function to be called
     * @param plugin Plugin where function is located
     */
    App.prototype.setPostRun = function (funcName, plugin) {
        this.setHook('_postRun', funcName, plugin);
    };
    /**
     * Removes a previously added function from a lifecycle method
     * @param lifecycle Lifecycle where function was added
     * @param funcName Name of function that was added
     */
    App.prototype.removeHook = function (lifecycle, funcName) {
        if (!this[lifecycle].has(funcName)) {
            throw new Error("".concat(funcName, " does not exist in ").concat(lifecycle));
        }
        //Override the plugin name
        this[lifecycle].delete(funcName);
    };
    /**
     * Helper function for each lifecycle method to set it's argument functions as hooks in the lifecycle
     * @param lifecycle Point in the lifecycle to place the function
     * @param funcName Name of function to be placed
     * @param plugin Plugin where function is located in
     */
    App.prototype.setHook = function (lifecycle, funcName, plugin) {
        if (this[lifecycle].has(funcName)) {
            throw new Error("".concat(funcName, " already declared for ").concat(lifecycle));
        }
        //Override the plugin name
        Object.defineProperty(plugin, 'name', { value: funcName });
        this[lifecycle].set(funcName, plugin);
    };
    /**
     * Assigns current app to a parent app.
     * Note! You can only have a maximum of 1 parent.
     * EzBackend follows Fastify's encapsulation system. Click [here](https://www.fastify.io/docs/latest/Encapsulation/) for more information on Fastify's encapsulation
     * @param app
     */
    App.prototype._setParent = function (app) {
        if (this._parent === undefined) {
            this._parent = app;
        }
        else {
            throw new Error("App's parent has already been set, parents can only be set once");
        }
    };
    App.prototype.addApp = function (arg1, arg2, arg3) {
        if (arg3 === void 0) { arg3 = {}; }
        var name;
        var newApp;
        var opts;
        if (arg1 instanceof App && (arg2 instanceof Object || arg2 === undefined)) {
            //overload1
            name = "UnnamedApp".concat(this._unnamedCounter);
            this._unnamedCounter += 1;
            newApp = arg1;
            opts = arg2 !== null && arg2 !== void 0 ? arg2 : arg3;
        }
        else if (typeof arg1 === "string" && arg2 instanceof App && arg3 instanceof Object) {
            //overload2
            name = arg1;
            newApp = arg2;
            opts = arg3;
        }
        else {
            throw new Error("Invalid function signature for addApp()");
        }
        if (this._apps.has(name) || Object.values(this._apps).indexOf(newApp) !== -1) {
            throw new Error(("Child app ".concat(name, " already exists")));
        }
        newApp.name = name;
        newApp.opts = opts;
        newApp._setParent(this);
        this._apps.set(name, newApp);
    };
    App.prototype.getApp = function (name) {
        return this.apps.get(name);
    };
    /**
     * Retrieves the function assigned to the lifecycle method for the current app
     * @param lifecycle
     * @returns
     */
    App.prototype.getHookPlugin = function (lifecycle) {
        var _this = this;
        //URGENT TODO: Plugin edge test case where child has hook but parent does not
        var childPlugins = Array.from(this.apps.values()).reduce(function (previousPlugins, app) {
            var childPlugin = app.getHookPlugin(lifecycle);
            if (childPlugin) {
                previousPlugins.push(childPlugin);
            }
            return previousPlugins;
        }, []);
        if (this[lifecycle].size === 0 && childPlugins.length === 0) {
            return undefined;
        }
        var appFunc = function (instance, opts) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this[lifecycle].forEach(function (pluginFunc) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        /*
                        Take note he who dares venture here:
                        The base code compiles into js, so everything is Function there
                        However when the user writes his own code, the functions can be AsyncFunction
                        So the prototype may be empty
                        Which is why we need to define it if necessary
                        TODO: Add test case for above edge case
                        */
                        if (pluginFunc.prototype === undefined) {
                            pluginFunc.prototype = {};
                        }
                        //Make sure plugins run on the parent scope
                        pluginFunc.prototype[symbols_1.kScope] = PluginScope.PARENT;
                        //TODO: Test case/throw error to ensure that kApp is set for ALL plugins
                        pluginFunc.prototype[symbols_1.kApp] = this;
                        instance.use(pluginFunc, opts);
                        return [2 /*return*/];
                    });
                }); });
                childPlugins.forEach(function (childPlugin) {
                    instance.use(childPlugin, opts);
                });
                return [2 /*return*/];
            });
        }); };
        appFunc.prototype[symbols_1.kApp] = this;
        appFunc.prototype[symbols_1.kScope] = this.scope;
        //Override the encapsulating function's name
        Object.defineProperty(appFunc, 'name', { value: this.name });
        return appFunc;
    };
    /**
     * Starts the app running. You can pass in app options to configure how the app should run
     * @param opts
     */
    App.prototype.start = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._instance.started) {
                            throw new Error("App has been started already!");
                        }
                        //Configure encapsulation
                        this._instance.override = this.override;
                        //Recursively load plugins
                        exports.LIFECYCLE.forEach(function (lifecycle) {
                            var lifecyclePlugin = _this.getHookPlugin(lifecycle);
                            if (lifecyclePlugin) {
                                Object.defineProperty(lifecyclePlugin, 'name', { value: lifecycle });
                                _this._instance.use(lifecyclePlugin, opts);
                            }
                        });
                        //Start the instance
                        this._instance.start();
                        return [4 /*yield*/, this._instance.ready()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param varName
     * @param override
     */
    App.prototype.setCustomOverride = function (varName, override) {
        this._overrides[varName] = override;
    };
    return App;
}());
exports.App = App;
//# sourceMappingURL=app.js.map